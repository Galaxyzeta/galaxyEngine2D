# Galaxy Engine 2D 一期规划

## P0 核心组件

### 1 高效能核心循环

`masterLoop` 负责启动全部子协程，包括：

- `subWorkerLoop` 将会开启多个，建议开启 CPU 逻辑核数个，负责最关键的游戏对象生命周期计算。
- `inputListener` 负责用户输入的监听，并通过 `channel` 将用户输入写到 `RingBuffer` 中。采取了订阅发布模式。
- `openGLRoutine` 调用 OpenGL API ，发起 draw call 进行前端渲染。单协程。

如何做到高性能：

1. 数量合适的协程。
2. 乐观锁、悲观锁相结合，以乐观锁为主。

### 2 核心资源管理

- `SynergyGate` 组件：
  
  实际上就是简化版本的 java 的 `CyclicBarrier`，用于同步所有协程执行到某一步骤后，统一继续执行。设计这个是为了在多协程环境下避免执行顺序发生错乱。

- `IGameObject2D` 接口：
  
  所有游戏对象都实现此接口，包含方法 `GetGameObject2D`，用于拿到具体的游戏对象。

- `GameObject2D` 结构体：
  
  所有具体的游戏对象都必须包含此父 struct，该 struct 包含了与游戏状态相关联的重要内容。

- `activePool` 和 `inactivePool`：
  
  都是 Hashset，前者用于存放全部活跃状态的游戏对象，这些对象会参与到核心事件的循环中；后者存放当前不活跃，但仍有可能转化为活跃状态的游戏对象，这些对象不参与核心事件循环。

  区分 active 和 inactive 是游戏性能优化的最关键部分。许多开放世界游戏不可能让所有对象都参与游戏循环，这样对计算资源的浪费是非常大的，一些不在镜头内的对象是完全没有必要进行计算的，但又能将其彻底移出内存（因为当镜头转回来的时候它们还得继续表演），这些对象就可以暂时存放到 inactive 资源池中。

- `mutextList`：
  
  一个存放锁的全局列表，只读。通过预定义的常量拿到对某个全局资源的线程安全读写控制。

- `casList`：

  一个存放 int32 变量的只读全局列表。用于通过 CAS 操作保证某些全局资源只被创建一次。

- `register/unregister channel`：
  
  每个 `subLoop` 各配备一个 `register/unregister` 通道，用于在对象创建步骤/对象销毁步骤统一创造/回收 `activePool` 和 `inactivePool` 中的资源。

- 对象池副本
  
  每个 `subLoop` 只负责对自身维护的对象池一部分指针的 copy 进行单步更新操作。在多协程的环境下，可以安全的实现对整个对象池的对象的更新操作。

- 负载均衡
  
  对象创建时执行 Load Balancing 算法，把对某个对象的创建请求路由到具体的 `subLoop` 中，并将对象的指针添加到该子协程的对象池中，以后该 `subLoop` 全权控制该对象的更新操作。

- 生命周期说明：
  
  - 每一个 `subLoop` 内有一个无限循环，以 `physicalFPS` 的频率尽可能保证物理更新的及时性（当然如果单步计算耗时太长当然无法保证每秒执行 60 次，因此会出现掉帧）。
  
  - 执行顺序：
     - 资源创建：通过 `register` 通道拉取资源创建请求，并将对象加入对象池中，以赋予该对象“生命”。
     - 单步更新：对于自己负责的 `activePool` 中的一部分对象副本，乱序执行它们的单步更新函数。  
     - 资源销毁：通过 `unregister` 通道拉取资源销毁请求，并将对象彻底移出对象池，以撤销该对象的“生命”。

- `Scene` 资源管理：
  
  通过一个全局列表管理本游戏的全部场景资源。在 SDK 中添加一个切换场景的操作，该操作：
  - 回收当前场景的全部资源。
  - 执行 `Scene init` 方法，用户在该方法中可以添加活跃的 `Loading` 逻辑组件，以及对 `Scene` 进行初始化操作，例如创建世界，添加对象。该方法由额外的协程进行处理，并由用户保证内部创建的资源全部被添加到 `inactive` 资源池中。一方面是由于加载时间可能很长，如果采用同步方法会导致系统无响应。第二点是采取了异步的方法之后，可以顺利引入 loading 界面实现“降级”处理。
  - 同步激活 `inactive` 资源池内容，实现场景的成功切换。

- 输入监听：
  
  使用一个全局的 `inputListener` 监听用户输入，采用发布订阅 + 懒加载（或用户手动打开）模式，一旦发现物体调用 `GetInput` 系列函数，就会把该对象自带的 `inputChannel` 进行初始化，并订阅全局的 `inputListener`。全局 `inputListener` 对用户输入进行监听，并在收到按键请求后，通过 `channel` 将按键 byte 码分发给全部的订阅者。

## P1 

## P2 应用层插件支持